stages:
  - build_x86
  # - test
  # - publish
  # - cleanup

variables:
  SPLUNK_BUILD_URL:
    value: https://repo.splunk.com/artifactory/Jenkins-POC/patch_9.0.3/linux/intel/64/splunk/9.0.3/splunk-9.0.3-dd0128b1f8cd-Linux-x86_64.tgz
    description: Build URL for Splunk Enterprise Linux x86_64 image
  UF_BUILD_URL:
    value: https://repo.splunk.com/artifactory/Jenkins-POC/patch_9.0.3/linux/intel/64/splunkforwarder/9.0.3/splunkforwarder-9.0.3-dd0128b1f8cd-Linux-x86_64.tgz
    description: Build URL for Universal Forwarder Linux x86_64 image
  S390_BUILD_URL:
    value: https://repo.splunk.com/artifactory/Jenkins-POC/patch_9.0.3/s390x/intel/64/splunkforwarder/9.0.3/splunkforwarder-9.0.3-dd0128b1f8cd-Linux-s390x.tgz
    description: Build URL for Universal Forwarder Linux s390x image
  SPLUNK_BRANCH:
    value: aurum
    description: Release branch to pull the images from
  SPLUNK_HASH:
    value: dd0128b1f8cd
    description: SPLCORE Git commit hash to use
  SPLUNK_VERSION:
    value: 9.0.3
    description: Splunk Enterprise release version
  PLATFORM:
    value: redhat-8
    description: Base OS to use for the container
  SPLUNK_ANSIBLE_BRANCH:
    value: develop
    description: Specify which branch of the Splunk-Ansible repository to pull from
  DOCKER_SPLUNK_BRANCH:
    value: develop
    description: Specify which branch of the Docker-Splunk repository to pull from
  DOCKER_BUILD_FLAGS: --no-cache
  IMG_REPO_DEST: repo.splunk.com/splunk/builds
  ID_TAG:
    value: -patch
    description: Specify an extra identifying tag for publishing images
  DOCKERHUB_TARGET:
    value: splunk/
    description: Initial run should be the default splunk/stg-. After validating the staging images, rebuild the plan with the target splunk/ to push to the public repositories.
  IMAGE_TAGS:
    value: dd0128b1f8cd,9.0.3,9.0,latest
    description: Tags to push the image to Docker Hub with. Should include latest if and only if appropriate.
  PUBLISH_S390X:
    value: 0
    description: Binary toggle to include s390x images in the manifest
  PROD_RELEASE:
    value: "false"
    description: Set the value "true" (without quotes) to - push docker hub images and publish splunk and UF manifests. Use with caution

#####################
# Build Images
#####################

.setup:
  rules:
      # Run when triggered via the web UI. 
      - if: $CI_PIPELINE_SOURCE == 'web'

build-splunk-x86-64:
  extends: .setup
  stage: build_x86
  needs: []
  allow_failure: false
  before_script:
    - echo ${SA_PASSWORD} | base64 -d | docker login --username ${SA_USERNAME} --password-stdin repo.splunk.com
    - echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
  script:
    - git clone https://github.com/splunk/docker-splunk.git
    - cd docker-splunk
    - git checkout ${DOCKER_SPLUNK_BRANCH}
    - SPLUNK_LINUX_BUILD_URL=${SPLUNK_BUILD_URL} SPLUNK_ANSIBLE_BRANCH=${SPLUNK_ANSIBLE_BRANCH} DOCKER_BUILD_FLAGS=${DOCKER_BUILD_FLAGS} make splunk-${PLATFORM}
    - docker tag splunk-${PLATFORM}:latest ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/splunk-${PLATFORM}:${SPLUNK_HASH}${ID_TAG}
    - |
      if [ "$PROD_RELEASE" == "true" ] ; then
        docker push ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/splunk-${PLATFORM}:${SPLUNK_HASH}${ID_TAG}
      else
        echo "Not a PROD_RELEASE run, skip docker push action"
      fi

    # Retag SE image
    - SPLUNK_IMG_ID=$(docker image ls --filter reference=${IMG_REPO_DEST}/${SPLUNK_BRANCH}/splunk-${PLATFORM}:${SPLUNK_HASH}${ID_TAG} --format '{{ .ID }}')
    - echo SPLUNK_IMG_ID=${SPLUNK_IMG_ID} > sbuild.env
    - echo "Image ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/splunk-${PLATFORM}:${SPLUNK_HASH} has ID ${SPLUNK_IMG_ID}"
    - docker tag splunk-${PLATFORM}:latest ${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH}
    - |
      if [ "$PROD_RELEASE" == "true" ] ; then
        docker push ${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH}
      else
        echo "Not a PROD_RELEASE run, skip docker push action"
      fi

  after_script:
    - docker rmi base-${PLATFORM} splunk-${PLATFORM} || true
    - docker rmi ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/splunk-${PLATFORM}:${SPLUNK_HASH}${ID_TAG} || true
    - docker rmi ${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH} || true
    - docker image prune -f
  artifacts:
    reports:
      dotenv: sbuild.env

build-uf-x86-64:
  extends: .setup
  stage: build_x86
  needs: []
  allow_failure: false
  before_script:
    - echo ${SA_PASSWORD} | base64 -d | docker login --username ${SA_USERNAME} --password-stdin repo.splunk.com
    - echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
  script:
    - git clone https://github.com/splunk/docker-splunk.git
    - cd docker-splunk
    - git checkout ${DOCKER_SPLUNK_BRANCH}
    - UF_LINUX_BUILD_URL=${UF_BUILD_URL} SPLUNK_ANSIBLE_BRANCH=${SPLUNK_ANSIBLE_BRANCH} DOCKER_BUILD_FLAGS=${DOCKER_BUILD_FLAGS} make uf-${PLATFORM}
    - docker tag uf-${PLATFORM}:latest ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/uf-${PLATFORM}:${SPLUNK_HASH}${ID_TAG}
    - |
      if [ "$PROD_RELEASE" == "true" ] ; then
        docker push ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/uf-${PLATFORM}:${SPLUNK_HASH}${ID_TAG}
      else
        echo "Not a PROD_RELEASE run, skip docker push action"
      fi

    # Retag UF images
    - UF_IMG_ID=$(docker image ls --filter reference=${IMG_REPO_DEST}/${SPLUNK_BRANCH}/uf-${PLATFORM}:${SPLUNK_HASH}${ID_TAG} --format '{{ .ID }}')
    - echo "UF_IMG_ID=${UF_IMG_ID}" > ufbuild.env
    - echo Image ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/uf-${PLATFORM}:${SPLUNK_HASH}${ID_TAG} has ID ${UF_IMG_ID}
    - docker tag uf-${PLATFORM}:latest ${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH}
    - |
      if [ "$PROD_RELEASE" == "true" ] ; then
        docker push ${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH}
      else
        echo "Not a PROD_RELEASE run, skip docker push action"
      fi

  after_script:
    - docker rmi base-${PLATFORM} uf-${PLATFORM} || true
    - docker rmi ${IMG_REPO_DEST}/${SPLUNK_BRANCH}/uf-${PLATFORM}:${SPLUNK_HASH}${ID_TAG} || true
    - docker rmi ${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH} || true
    - docker image prune -f
  artifacts:
    reports:
      dotenv: ufbuild.env

sanity-check:
  extends: .setup
  stage: test
  allow_failure: true
  before_script:
    - echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
  script:
    - SE_AMD64=$(docker inspect ${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH} --format '{{index .RepoDigests 0}}')
    - echo SE_AMD64=${SE_AMD64} > check.env
    - echo "hash of '${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH}${ID_TAG}' is '${SE_AMD64}'"
    - UF_AMD64=$(docker inspect ${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH} --format '{{index .RepoDigests 0}}')
    - echo UF_AMD64=${UF_AMD64} >> check.env
    - echo "hash of '${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH}${ID_TAG}' is '${UF_AMD64}'"
    - ${PUBLISH_S390X} && UF_S390X=$(docker inspect ${DOCKERHUB_TARGET}universalforwarder-s390x-linux:${SPLUNK_HASH} --format '{{index .RepoDigests 0}}') || true
    - ${PUBLISH_S390X} && echo UF_S390X=${UF_S390X} >> check.env || true
    - ${PUBLISH_S390X} && echo "hash of '${DOCKERHUB_TARGET}universalforwarder-s390x-linux:${SPLUNK_HASH}${ID_TAG}' is '${UF_S390X}'" || true
  artifacts:
    reports:
      dotenv: check.env

publish-splunk-manifest:
  extends: .setup
  stage: publish
  dependencies:
    - build-splunk-x86-64
    - sanity-check
  allow_failure: false
  before_script:
    - echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
  script:
    - docker pull ${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH}
    - SE_AMD64=$(docker inspect ${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH} --format '{{index .RepoDigests 0}}')
    - echo "hash of '${DOCKERHUB_TARGET}splunk-amd64-linux:${SPLUNK_HASH}' is '${SE_AMD64}'"
    - echo "pushing with tag '${IMAGE_TAGS}'"
    - DOCKER_CLI_EXPERIMENTAL=enabled docker manifest create --amend ${DOCKERHUB_TARGET}splunk:${IMAGE_TAGS} $SE_AMD64
    - DOCKER_CLI_EXPERIMENTAL=enabled docker manifest annotate ${DOCKERHUB_TARGET}splunk:${IMAGE_TAGS} $SE_AMD64 --os linux --arch amd64
    - DOCKER_CLI_EXPERIMENTAL=enabled docker manifest push --purge ${DOCKERHUB_TARGET}splunk:${IMAGE_TAGS}
  rules:
      # Run only if PROD_RELEASE is set to true
      - if: $PROD_RELEASE == 'true'


publish-uf-manifest:
  extends: .setup
  stage: publish
  dependencies:
    - build-uf-x86-64
    - sanity-check
  allow_failure: false
  before_script:
    - echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
  script:
    - docker pull ${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH}
    - UF_AMD64=$(docker inspect ${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH} --format '{{index .RepoDigests 0}}')
    - echo "hash of '${DOCKERHUB_TARGET}universalforwarder-amd64-linux:${SPLUNK_HASH}' is '${UF_AMD64}'"
    - echo "pushing with tag '${IMAGE_TAGS}'"
    - DOCKER_CLI_EXPERIMENTAL=enabled docker manifest create --amend ${DOCKERHUB_TARGET}universalforwarder:${IMAGE_TAGS} $UF_AMD64
    - DOCKER_CLI_EXPERIMENTAL=enabled docker manifest annotate ${DOCKERHUB_TARGET}universalforwarder:${IMAGE_TAGS} $UF_AMD64 --os linux --arch amd64
    - DOCKER_CLI_EXPERIMENTAL=enabled docker manifest push --purge ${DOCKERHUB_TARGET}universalforwarder:${IMAGE_TAGS}
  rules:
      # Run only if PROD_RELEASE is set to true
      - if: $PROD_RELEASE == 'true'


cleanup:
  extends: .setup
  stage: cleanup
  allow_failure: true
  before_script:
    - echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
  script:
    - TAGLIST="${IMAGE_TAGS},${SPLUNK_HASH}"
    - |+
      for tag in TAGLIST
      do
        docker rmi \$(docker images --format '{{.Repository}}:{{.Tag}}' | grep ${tag}) || true
      done
    - docker system prune -f
    - docker logout
